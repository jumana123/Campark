/*!
 * svelte-google-maps - Google Maps components for Svelte
 * v0.2.0 - https://github.com/timhall/svelte-google-maps - @license: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.SvelteGoogleMaps = {})));
}(this, (function (exports) { 'use strict';

let loading;

async function load(url) {
  if (window.google && window.google.maps) return google.maps;
  if (loading) return loading;

  loading = new Promise((resolve, reject) => {
    window.__SvelteGoogleMapsInit = () => resolve(google.maps);

    const src = url + '&callback=__SvelteGoogleMapsInit';
    const script = document.createElement('script');
    script.onerror = () => reject(new Error(`Failed to load google maps scripts (${src})`));
    script.async = true;
    script.defer = true;
    script.charset = 'utf-8';
    script.src = src;

    const firstScript = document.getElementsByTagName("script")[0];
    firstScript.parentNode.insertBefore(script, firstScript);
  });

  return loading;
}

function deferred() {
  let _resolve, _reject;
  
  const later = new Promise((resolve, reject) => {
    _resolve = resolve;
    _reject = reject;
  });

  later.resolve = _resolve;
  later.reject = _reject;

  return later;
}

function changer() {
  let changing = false;

  return callback => {
    if (changing) return;

    changing = true;
    callback();
    changing = false;
  };
}

function defer(callback) {
  setTimeout(callback, 0);
}

class Context {
  constructor(API_KEY, options = {}) {
    const { beta = false } = options;
    window.API_KEY = API_KEY;
    this.url = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}${
      beta ? '&v=3.exp&use_slippy=true' : ''
    }`;

    this.api = deferred();
    this.map = deferred();
  }

  async load(element, options) {
    const api = await load(this.url);
    const map = new api.Map(element, options);

    this.api.resolve(api);
    this.map.resolve(map);

    return { api, map };
  }

  async ready() {
    const api = await this.api;
    const map = await this.map;

    return { api, map };
  }
}

function noop() {}

function assign(target) {
	var k,
		source,
		i = 1,
		len = arguments.length;
	for (; i < len; i++) {
		source = arguments[i];
		for (k in source) target[k] = source[k];
	}

	return target;
}

function appendNode(node, target) {
	target.appendChild(node);
}

function insertNode(node, target, anchor) {
	target.insertBefore(node, anchor);
}

function detachNode(node) {
	node.parentNode.removeChild(node);
}

function reinsertChildren(parent, target) {
	while (parent.firstChild) target.appendChild(parent.firstChild);
}

function createElement(name) {
	return document.createElement(name);
}

function createSvgElement(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function createText(data) {
	return document.createTextNode(data);
}

function setAttribute(node, attribute, value) {
	node.setAttribute(attribute, value);
}

function children (element) {
	return Array.from(element.childNodes);
}

function claimElement (nodes, name, attributes, svg) {
	for (var i = 0; i < nodes.length; i += 1) {
		var node = nodes[i];
		if (node.nodeName === name) {
			for (var j = 0; j < node.attributes.length; j += 1) {
				var attribute = node.attributes[j];
				if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
			}
			return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
		}
	}

	return svg ? createSvgElement(name) : createElement(name);
}

function claimText (nodes, data) {
	for (var i = 0; i < nodes.length; i += 1) {
		var node = nodes[i];
		if (node.nodeType === 3) {
			node.data = data;
			return nodes.splice(i, 1)[0];
		}
	}

	return createText(data);
}

function setStyle(node, key, value) {
	node.style.setProperty(key, value);
}

function blankObject() {
	return Object.create(null);
}

function destroy(detach) {
	this.destroy = noop;
	this.fire('destroy');
	this.set = this.get = noop;

	if (detach !== false) this._fragment.u();
	this._fragment.d();
	this._fragment = this._state = null;
}

function destroyDev(detach) {
	destroy.call(this, detach);
	this.destroy = function() {
		console.warn('Component was already destroyed');
	};
}

function differs(a, b) {
	return a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}

function dispatchObservers(component, group, changed, newState, oldState) {
	for (var key in group) {
		if (!changed[key]) continue;

		var newValue = newState[key];
		var oldValue = oldState[key];

		var callbacks = group[key];
		if (!callbacks) continue;

		for (var i = 0; i < callbacks.length; i += 1) {
			var callback = callbacks[i];
			if (callback.__calling) continue;

			callback.__calling = true;
			callback.call(component, newValue, oldValue);
			callback.__calling = false;
		}
	}
}

function fire(eventName, data) {
	var handlers =
		eventName in this._handlers && this._handlers[eventName].slice();
	if (!handlers) return;

	for (var i = 0; i < handlers.length; i += 1) {
		handlers[i].call(this, data);
	}
}

function get(key) {
	return key ? this._state[key] : this._state;
}

function init(component, options) {
	component._observers = { pre: blankObject(), post: blankObject() };
	component._handlers = blankObject();
	component._bind = options._bind;

	component.options = options;
	component.root = options.root || component;
	component.store = component.root.store || options.store;
}

function observe(key, callback, options) {
	var group = options && options.defer
		? this._observers.post
		: this._observers.pre;

	(group[key] || (group[key] = [])).push(callback);

	if (!options || options.init !== false) {
		callback.__calling = true;
		callback.call(this, this._state[key]);
		callback.__calling = false;
	}

	return {
		cancel: function() {
			var index = group[key].indexOf(callback);
			if (~index) group[key].splice(index, 1);
		}
	};
}

function observeDev(key, callback, options) {
	var c = (key = '' + key).search(/[^\w]/);
	if (c > -1) {
		var message =
			'The first argument to component.observe(...) must be the name of a top-level property';
		if (c > 0)
			message += ", i.e. '" + key.slice(0, c) + "' rather than '" + key + "'";

		throw new Error(message);
	}

	return observe.call(this, key, callback, options);
}

function on(eventName, handler) {
	if (eventName === 'teardown') return this.on('destroy', handler);

	var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
	handlers.push(handler);

	return {
		cancel: function() {
			var index = handlers.indexOf(handler);
			if (~index) handlers.splice(index, 1);
		}
	};
}

function onDev(eventName, handler) {
	if (eventName === 'teardown') {
		console.warn(
			"Use component.on('destroy', ...) instead of component.on('teardown', ...) which has been deprecated and will be unsupported in Svelte 2"
		);
		return this.on('destroy', handler);
	}

	return on.call(this, eventName, handler);
}

function set(newState) {
	this._set(assign({}, newState));
	if (this.root._lock) return;
	this.root._lock = true;
	callAll(this.root._beforecreate);
	callAll(this.root._oncreate);
	callAll(this.root._aftercreate);
	this.root._lock = false;
}

function _set(newState) {
	var oldState = this._state,
		changed = {},
		dirty = false;

	for (var key in newState) {
		if (differs(newState[key], oldState[key])) changed[key] = dirty = true;
	}
	if (!dirty) return;

	this._state = assign({}, oldState, newState);
	this._recompute(changed, this._state);
	if (this._bind) this._bind(changed, this._state);

	if (this._fragment) {
		dispatchObservers(this, this._observers.pre, changed, this._state, oldState);
		this._fragment.p(changed, this._state);
		dispatchObservers(this, this._observers.post, changed, this._state, oldState);
	}
}

function setDev(newState) {
	if (typeof newState !== 'object') {
		throw new Error(
			this._debugName + '.set was called without an object of data key-values to update.'
		);
	}

	this._checkReadOnly(newState);
	set.call(this, newState);
}

function callAll(fns) {
	while (fns && fns.length) fns.pop()();
}

function _mount(target, anchor) {
	this._fragment.m(target, anchor);
}

function _unmount() {
	if (this._fragment) this._fragment.u();
}

var protoDev = {
	destroy: destroyDev,
	get: get,
	fire: fire,
	observe: observeDev,
	on: onDev,
	set: setDev,
	teardown: destroyDev,
	_recompute: noop,
	_set: _set,
	_mount: _mount,
	_unmount: _unmount
};

const supported = typeof IntersectionObserver !== 'undefined' && typeof WeakMap !== 'undefined';

let observer;
let listeners;
if (supported) {
  listeners = new WeakMap();

  const notify = entries => {
    for (const entry of entries) {
      const listener = listeners.get(entry.target);
      if (listener) listener();
    }
  };

  observer = new IntersectionObserver(notify);
}

function intersection(node, callback) {
  if (!supported) {
    defer(callback);
    return { teardown() {} };
  }

  listeners.set(node, callback);
  observer.observe(node);

  return {
    teardown() {
      listeners.delete(node);
      observer.unobserve(node);
    }
  }
}

/* Map.html generated by Svelte v1.51.0 */
function data() {
  return {
    defer: false,
    center: { lat: 0, lng: 0 },
    zoom: 8,
    instance: null,
    loading: null,
    loaded: false
  };
}

var methods = {
  async load() {
    let { instance, map: context, center, zoom, loaded, loading } = this.get();

    if (loaded) return instance;
    if (loading) return loading;

    loading = context.load(this.refs.map, { center, zoom }).then(({ map }) => map);
    this.set({ loaded: false, loading });

    instance = await loading;

    // Setup two-way binding between component and map
    // - Use `changer` to avoid additional sets/changes for internal changes
    const change = changer();

    // Attach listeners to instance
    instance.addListener('zoom_changed', () => {
      change(() => {
        const zoom = instance.getZoom();
        this.set({ zoom });
      });
    });

    instance.addListener('center_changed', () => {          
      change(() => {
        const center = instance.getCenter();
        const lat = center.lat();
        const lng = center.lng();

        this.set({ center: { lat, lng } });
      });
    });

    // Attach observers to component
    this.observe('center', center => {
      change(() => instance.setCenter(center));
    }, { init: false });

    this.observe('zoom', zoom => {
      change(() => instance.setZoom(zoom));
    }, { init: false });

    this.set({ instance, loaded: true, loading: null });

    return instance;
  }
};

function oncreate() {
  // Load map immediately or wait defer until intersection
  const defer$$1 = this.get('defer');
  if (!defer$$1 || defer$$1 === 'false') this.load();
}

async function ondestroy() {
  let { instance, loading } = this.get();
  
  if (!instance && loading) instance = await loading;
  if (!instance) return;

  // TODO Remove listeners from instance
  console.log('destroy', instance);
}

function encapsulateStyles(node) {
	setAttribute(node, "svelte-1791593990", "");
}

function add_css() {
	var style = createElement("style");
	style.id = 'svelte-1791593990-style';
	style.textContent = "[svelte-ref-map][svelte-1791593990]{width:100%;height:100%}[svelte-ref-children][svelte-1791593990]{visibility:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFwLmh0bWwiLCJzb3VyY2VzIjpbIk1hcC5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbIjxkaXYgcmVmOm1hcCBvbjppbnRlcnNlY3Rpb249XCJsb2FkKClcIj48L2Rpdj5cbjxkaXYgcmVmOmNoaWxkcmVuPjxzbG90IC8+PC9kaXY+XG5cbjxzdHlsZT5cbiAgcmVmOm1hcCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG5cbiAgcmVmOmNoaWxkcmVuIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGludGVyc2VjdGlvbiB9IGZyb20gJy4vc3JjL2V2ZW50cyc7XG4gIGltcG9ydCB7IGNoYW5nZXIgfSBmcm9tICcuL3NyYy91dGlscyc7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWZlcjogZmFsc2UsXG4gICAgICAgIGNlbnRlcjogeyBsYXQ6IDAsIGxuZzogMCB9LFxuICAgICAgICB6b29tOiA4LFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbnVsbCxcbiAgICAgICAgbG9hZGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7IGludGVyc2VjdGlvbiB9LFxuXG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAvLyBMb2FkIG1hcCBpbW1lZGlhdGVseSBvciB3YWl0IGRlZmVyIHVudGlsIGludGVyc2VjdGlvblxuICAgICAgY29uc3QgZGVmZXIgPSB0aGlzLmdldCgnZGVmZXInKTtcbiAgICAgIGlmICghZGVmZXIgfHwgZGVmZXIgPT09ICdmYWxzZScpIHRoaXMubG9hZCgpO1xuICAgIH0sXG5cbiAgICBhc3luYyBvbmRlc3Ryb3koKSB7XG4gICAgICBsZXQgeyBpbnN0YW5jZSwgbG9hZGluZyB9ID0gdGhpcy5nZXQoKTtcbiAgICAgIFxuICAgICAgaWYgKCFpbnN0YW5jZSAmJiBsb2FkaW5nKSBpbnN0YW5jZSA9IGF3YWl0IGxvYWRpbmc7XG4gICAgICBpZiAoIWluc3RhbmNlKSByZXR1cm47XG5cbiAgICAgIC8vIFRPRE8gUmVtb3ZlIGxpc3RlbmVycyBmcm9tIGluc3RhbmNlXG4gICAgICBjb25zb2xlLmxvZygnZGVzdHJveScsIGluc3RhbmNlKTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgYXN5bmMgbG9hZCgpIHtcbiAgICAgICAgbGV0IHsgaW5zdGFuY2UsIG1hcDogY29udGV4dCwgY2VudGVyLCB6b29tLCBsb2FkZWQsIGxvYWRpbmcgfSA9IHRoaXMuZ2V0KCk7XG5cbiAgICAgICAgaWYgKGxvYWRlZCkgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICBpZiAobG9hZGluZykgcmV0dXJuIGxvYWRpbmc7XG5cbiAgICAgICAgbG9hZGluZyA9IGNvbnRleHQubG9hZCh0aGlzLnJlZnMubWFwLCB7IGNlbnRlciwgem9vbSB9KS50aGVuKCh7IG1hcCB9KSA9PiBtYXApO1xuICAgICAgICB0aGlzLnNldCh7IGxvYWRlZDogZmFsc2UsIGxvYWRpbmcgfSk7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBsb2FkaW5nO1xuXG4gICAgICAgIC8vIFNldHVwIHR3by13YXkgYmluZGluZyBiZXR3ZWVuIGNvbXBvbmVudCBhbmQgbWFwXG4gICAgICAgIC8vIC0gVXNlIGBjaGFuZ2VyYCB0byBhdm9pZCBhZGRpdGlvbmFsIHNldHMvY2hhbmdlcyBmb3IgaW50ZXJuYWwgY2hhbmdlc1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VyKCk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGxpc3RlbmVycyB0byBpbnN0YW5jZVxuICAgICAgICBpbnN0YW5jZS5hZGRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgKCkgPT4ge1xuICAgICAgICAgIGNoYW5nZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gaW5zdGFuY2UuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdGhpcy5zZXQoeyB6b29tIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGluc3RhbmNlLmFkZExpc3RlbmVyKCdjZW50ZXJfY2hhbmdlZCcsICgpID0+IHsgICAgICAgICAgXG4gICAgICAgICAgY2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGluc3RhbmNlLmdldENlbnRlcigpO1xuICAgICAgICAgICAgY29uc3QgbGF0ID0gY2VudGVyLmxhdCgpO1xuICAgICAgICAgICAgY29uc3QgbG5nID0gY2VudGVyLmxuZygpO1xuXG4gICAgICAgICAgICB0aGlzLnNldCh7IGNlbnRlcjogeyBsYXQsIGxuZyB9IH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCBvYnNlcnZlcnMgdG8gY29tcG9uZW50XG4gICAgICAgIHRoaXMub2JzZXJ2ZSgnY2VudGVyJywgY2VudGVyID0+IHtcbiAgICAgICAgICBjaGFuZ2UoKCkgPT4gaW5zdGFuY2Uuc2V0Q2VudGVyKGNlbnRlcikpO1xuICAgICAgICB9LCB7IGluaXQ6IGZhbHNlIH0pO1xuXG4gICAgICAgIHRoaXMub2JzZXJ2ZSgnem9vbScsIHpvb20gPT4ge1xuICAgICAgICAgIGNoYW5nZSgoKSA9PiBpbnN0YW5jZS5zZXRab29tKHpvb20pKTtcbiAgICAgICAgfSwgeyBpbml0OiBmYWxzZSB9KTtcblxuICAgICAgICB0aGlzLnNldCh7IGluc3RhbmNlLCBsb2FkZWQ6IHRydWUsIGxvYWRpbmc6IG51bGwgfSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbjwvc2NyaXB0PlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlFLG1DQUFRLENBQUMsQUFDUCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2QsQ0FBQyxBQUVELHdDQUFhLENBQUMsQUFDWixVQUFVLENBQUUsTUFBTSxBQUNwQixDQUFDIn0= */";
	appendNode(style, document.head);
}

function create_main_fragment(state, component) {
	var div, intersection_handler, text, div_1, slot_content_default = component._slotted.default;

	return {
		c: function create() {
			div = createElement("div");
			text = createText("\n");
			div_1 = createElement("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claimElement(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			div_nodes.forEach(detachNode);
			text = claimText(nodes, "\n");

			div_1 = claimElement(nodes, "DIV", {}, false);
			var div_1_nodes = children(div_1);

			div_1_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			encapsulateStyles(div);
			setAttribute(div, "svelte-ref-map", "");

			intersection_handler = intersection.call(component, div, function(event) {
				component.load();
			});

			encapsulateStyles(div_1);
			setAttribute(div_1, "svelte-ref-children", "");
		},

		m: function mount(target, anchor) {
			insertNode(div, target, anchor);
			component.refs.map = div;
			insertNode(text, target, anchor);
			insertNode(div_1, target, anchor);

			if (slot_content_default) {
				appendNode(slot_content_default, div_1);
			}

			component.refs.children = div_1;
		},

		p: noop,

		u: function unmount() {
			detachNode(div);
			detachNode(text);
			detachNode(div_1);

			if (slot_content_default) {
				reinsertChildren(div_1, slot_content_default);
			}
		},

		d: function destroy$$1() {
			intersection_handler.teardown();
			if (component.refs.map === div) component.refs.map = null;
			if (component.refs.children === div_1) component.refs.children = null;
		}
	};
}

function Map(options) {
	this._debugName = '<Map>';
	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
	init(this, options);
	this.refs = {};
	this._state = assign(data(), options.data);

	this._handlers.destroy = [ondestroy];

	this._slotted = options.slots || {};

	if (!document.getElementById("svelte-1791593990-style")) add_css();

	var _oncreate = oncreate.bind(this);

	if (!options.root) {
		this._oncreate = [_oncreate];
	} else {
	 	this.root._oncreate.push(_oncreate);
	 }

	this.slots = {};

	this._fragment = create_main_fragment(this._state, this);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._fragment.m(options.target, options.anchor || null);

		callAll(this._oncreate);
	}
}

assign(Map.prototype, methods, protoDev);

Map.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* Marker.html generated by Svelte v1.51.0 */
function data$1() {
	return { marker: deferred() };
}

async function oncreate$1() {
  let { map: context, position, title, label, icon } = this.get();

  const { api, map } = await context.ready();

  const marker = new api.Marker({
    position,
    title,
    label,
    icon,
    map
  });

  marker.addListener('click', event => {
    this.fire('click', { marker });
  });

  this.get('marker').resolve(marker);
}

async function ondestroy$1() {
  const marker = await this.get('marker');
  marker.setMap(null);
}

function create_main_fragment$1(state, component) {

	return {
		c: noop,

		l: noop,

		m: noop,

		p: noop,

		u: noop,

		d: noop
	};
}

function Marker(options) {
	this._debugName = '<Marker>';
	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
	init(this, options);
	this._state = assign(data$1(), options.data);

	this._handlers.destroy = [ondestroy$1];

	var _oncreate = oncreate$1.bind(this);

	if (!options.root) {
		this._oncreate = [_oncreate];
	} else {
	 	this.root._oncreate.push(_oncreate);
	 }

	this._fragment = create_main_fragment$1(this._state, this);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._fragment.m(options.target, options.anchor || null);

		callAll(this._oncreate);
	}
}

assign(Marker.prototype, protoDev);

Marker.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* Polyline.html generated by Svelte v1.51.0 */
function data$2() {
  return {
    polyline: deferred()
  };
}

async function oncreate$2() {
  const { map: context, path, color: strokeColor, weight: strokeWeight } = this.get();

  const { api, map } = await context.ready();
  const polyline = new api.Polyline({
    path,
    geodesic: true,
    strokeColor,
    strokeWeight
  });

  polyline.setMap(map);
  this.get('polyline').resolve(polyline);
}

async function ondestroy$2() {
  const polyline = await this.get('polyline');
  polyline.setMap(null);
}

function create_main_fragment$2(state, component) {

	return {
		c: noop,

		l: noop,

		m: noop,

		p: noop,

		u: noop,

		d: noop
	};
}

function Polyline(options) {
	this._debugName = '<Polyline>';
	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
	init(this, options);
	this._state = assign(data$2(), options.data);

	this._handlers.destroy = [ondestroy$2];

	var _oncreate = oncreate$2.bind(this);

	if (!options.root) {
		this._oncreate = [_oncreate];
	} else {
	 	this.root._oncreate.push(_oncreate);
	 }

	this._fragment = create_main_fragment$2(this._state, this);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._fragment.m(options.target, options.anchor || null);

		callAll(this._oncreate);
	}
}

assign(Polyline.prototype, protoDev);

Polyline.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* Info.html generated by Svelte v1.51.0 */
function data$3() {
  return {
    info: deferred()
  };
}

async function oncreate$3() {
  const { map: context, position } = this.get();
  const content = this.refs.content;

  const { api, map } = await context.ready();
  const info = new api.InfoWindow({
    content,
    position
  });

  info.addListener('closeclick', () => this.fire('close', info));

  this.observe('position', position => {
    info.setPosition(position);

    // If another InfoWindow is opened (e.g. Place)
    // then component may not have been destroyed
    // -> check for no map on position change, and re-open
    if (!info.map) info.open(map);
  }, { init: false });
  
  info.open(map);
  this.get('info').resolve(info);
}

async function ondestroy$3() {
  const info = await this.get('info');
  info.close();
}

function create_main_fragment$3(state, component) {
	var div, div_1, slot_content_default = component._slotted.default;

	return {
		c: function create() {
			div = createElement("div");
			div_1 = createElement("div");
		},

		l: function claim(nodes) {
			div = claimElement(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			div_1 = claimElement(div_nodes, "DIV", {}, false);
			var div_1_nodes = children(div_1);

			div_1_nodes.forEach(detachNode);
			div_nodes.forEach(detachNode);
		},

		m: function mount(target, anchor) {
			insertNode(div, target, anchor);
			appendNode(div_1, div);

			if (slot_content_default) {
				appendNode(slot_content_default, div_1);
			}

			component.refs.content = div_1;
		},

		p: noop,

		u: function unmount() {
			detachNode(div);

			if (slot_content_default) {
				reinsertChildren(div_1, slot_content_default);
			}
		},

		d: function destroy$$1() {
			if (component.refs.content === div_1) component.refs.content = null;
		}
	};
}

function Info(options) {
	this._debugName = '<Info>';
	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
	init(this, options);
	this.refs = {};
	this._state = assign(data$3(), options.data);

	this._handlers.destroy = [ondestroy$3];

	this._slotted = options.slots || {};

	var _oncreate = oncreate$3.bind(this);

	if (!options.root) {
		this._oncreate = [_oncreate];
	} else {
	 	this.root._oncreate.push(_oncreate);
	 }

	this.slots = {};

	this._fragment = create_main_fragment$3(this._state, this);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._fragment.m(options.target, options.anchor || null);

		callAll(this._oncreate);
	}
}

assign(Info.prototype, protoDev);

Info.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* Overlay.html generated by Svelte v1.51.0 */
function data$4() {
  return {
    overlay: deferred(),
    mapPane: 'floatPane',
    translation: { x: 0, y: 0 }
  };
}

async function oncreate$4() {
  const { map: context, mapPane } = this.get();
  const container = this.refs.container;
  
  // Normalize offset into function that always returns { x, y }
  let getOffset = prepareOffset(this.get('offset'), container);

  const { api, map } = await context.ready();
  const overlay = new api.OverlayView();
  const component = this;

  overlay.onAdd = function () {
    const pane = this.getPanes()[mapPane];
    if (!pane) throw new Error(`No pane found for type "${mapPane}"`);

    pane.appendChild(container);
  };

  overlay.draw = function () {
    const { position, bounds } = component.get();
    
    if (position) {
      const { lat, lng } = position;
      const offset = getOffset();

      const projection = this.getProjection();
      const { x, y } = projection.fromLatLngToDivPixel(new api.LatLng(lat, lng));

      const translation = { x: x + offset.x, y: y + offset.y };
      component.set({ translation });
    } else if (bounds) {
      // TODO
    }
  };

  overlay.onRemove = () => {};

  // Redraw overlay on positioning changes
  this.observe('position', () => overlay.draw(), { init: false });
  this.observe('bounds', () => overlay.draw(), { init: false });
  this.observe('offset', value => {
    getOffset = prepareOffset(value, container);
    overlay.draw();
  }, { init: false });

  overlay.setMap(map);
  this.get('overlay').resolve(overlay);
}

async function ondestroy$4() {
  const overlay = await this.get('overlay');
  overlay.setMap(null);
}

function prepareOffset(offset, container) {
  if (typeof offset === 'function') {
    return () => {
      const value = offset(container);
      return { x: value && value.x || 0, y: value && value.y || 0 };
    };
  } else {
    const value = { x: offset && offset.x || 0, y: offset && offset.y || 0 };
    return () => value;
  }
}

function create_main_fragment$4(state, component) {
	var div, div_1, slot_content_default = component._slotted.default;

	return {
		c: function create() {
			div = createElement("div");
			div_1 = createElement("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claimElement(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			div_1 = claimElement(div_nodes, "DIV", { style: true }, false);
			var div_1_nodes = children(div_1);

			div_1_nodes.forEach(detachNode);
			div_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			setStyle(div_1, "transform", "translate(" + state.translation.x + "px, " + state.translation.y + "px)");
			setStyle(div_1, "position", "absolute");
		},

		m: function mount(target, anchor) {
			insertNode(div, target, anchor);
			appendNode(div_1, div);

			if (slot_content_default) {
				appendNode(slot_content_default, div_1);
			}

			component.refs.container = div_1;
		},

		p: function update(changed, state) {
			if (changed.translation) {
				setStyle(div_1, "transform", "translate(" + state.translation.x + "px, " + state.translation.y + "px)");
			}
		},

		u: function unmount() {
			detachNode(div);

			if (slot_content_default) {
				reinsertChildren(div_1, slot_content_default);
			}
		},

		d: function destroy$$1() {
			if (component.refs.container === div_1) component.refs.container = null;
		}
	};
}

function Overlay(options) {
	this._debugName = '<Overlay>';
	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
	init(this, options);
	this.refs = {};
	this._state = assign(data$4(), options.data);
	if (!('translation' in this._state)) console.warn("<Overlay> was created without expected data property 'translation'");

	this._handlers.destroy = [ondestroy$4];

	this._slotted = options.slots || {};

	var _oncreate = oncreate$4.bind(this);

	if (!options.root) {
		this._oncreate = [_oncreate];
	} else {
	 	this.root._oncreate.push(_oncreate);
	 }

	this.slots = {};

	this._fragment = create_main_fragment$4(this._state, this);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._fragment.m(options.target, options.anchor || null);

		callAll(this._oncreate);
	}
}

assign(Overlay.prototype, protoDev);

Overlay.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

// Assume UMD usage is in browser so include everything
//
// Example:
//
// <script src="https://unpkg.com/svelte-google-maps"></script>
// <script>
//   const { Context, Map, Marker } = SvelteGoogleMaps;
// </script>

exports.Context = Context;
exports.Map = Map;
exports.Marker = Marker;
exports.Polyline = Polyline;
exports.Info = Info;
exports.Overlay = Overlay;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=svelte-google-maps.js.map
